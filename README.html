<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">

<head>

<title>DDSLib: Dynamic data structures</title>

</head>

<body>

<h1>DDSLib: Dynamic data structures</h1>


<p>This is a library of C headers for manipulating miscellaneous
dynamic data structures.</p>

<h2>Installation</h2>

<p>To install in <samp>/usr/local</samp>, the usual commands should
work with the default configuration options:</p>

<pre class="spool">
$ <kbd>make</kbd>
$ <kbd>su</kbd>
# <kbd>make install</kbd>
</pre>

<p>However, you may want to configure compilation options or install
in a different location.  You can override the default configuration
by either:</p>

<ul>

<li><p>specifying variables on the command line, or by</p></li>

<li><p>placing them in a file called <samp>ddslib-env.mk</samp> in either:</p>

<ul>

<li><p>the <samp>ddslib</samp> directory, or in</p></li>

<li><p>the path that <samp>make</samp> searches
(e.g. <samp>/usr/local/include</samp> or <samp>/usr/include</samp>, or
any extra directories you have configured).</p></li>

</ul></li>

</ul>

<p>For example, you could have this file placed in
<samp>~/.install/include-config</samp>:</p>

<pre class="makefile">
# example ddslib-env.mk

# C options, language variant and optimisations
CC=gcc
CFLAGS += -std=gnu99
CFLAGS += -O2

# C++ options, language variant and optimisations
CXX=g++
CXXFLAGS += -std=gnu++98
CXXFLAGS += -O2

# Place to install the library
PREFIX=$(HOME)/.install

# To disable the compilation and installation of
# problematic headers if you don't have a full C99
# implementation:
#ENABLE_C99=no

# Similarly for C++:
#ENABLE_CXX=no
</pre>

<p>&hellip;and the environment variable <samp>MAKEFLAGS</samp> set to
<samp>"-I${HOME}/.install/include-config"</samp>.  When you run GNU
<samp>make</samp>, the settings above override the defaults.</p>

<h2 id="lists">Doubly-linked lists</h2>

<pre class=C>
#include &lt;ddslib/dllist.h&gt;
</pre>

<p>This header assumes that you want to maintain a list of structures in
which you've incorporated the necessary &lsquo;previous&rsquo; and
&lsquo;next&rsquo; pointers.  The list can be <dfn>open</dfn>, i.e. it
has a start and an end, or <dfn>closed</dfn>, i.e. it loops
continuously.</p>

<p>As an example, let's assume that we have a structure for each list
element:</p>

<pre class=C>
struct mydata {
  int m1;
  char m2;
  /* ... */

  dllist_elem(struct mydata) others;
};
</pre>

<p>The member &lsquo;others&rsquo; provides the necessary pointers for
linking.</p>


<h3>Open lists</h3>

<p>An open list of elements has the type <code
class=C>dllist_hdr(struct mydata)</code>.  A <code
class=C>typedef</code> for the header type is recommended if you
intend to pass headers around, otherwise you might be asking the
compiler to compare identical, anonymous types:</p>

<pre class=C>
typedef dllist_hdr(struct mydata) mylist;
</pre>

<p>We can declare and initialise an empty, open list with:</p>

<pre class=C>
mylist list = dllist_HDRINIT;
</pre>

<p>&hellip;or initialise with:</p>

<pre class=C>
dllist_init(&amp;list);
</pre>

<p>Now if we have several elements to add:</p>

<pre class=C>
struct mydata e1, e2, e3, e4;
</pre>

<p>&hellip;we can add these to the list in various ways:</p>

<pre class=C>
/* add to end */
dllist_append(&amp;list, others, &amp;e1);

/* add to start */
dllist_prepend(&amp;list, others, &amp;e2);

/* add after e2 */
dllist_insertafter(&amp;list, others, &amp;e2, &amp;e3);

/* add before e3 */
dllist_insertbefore(&amp;list, others, &amp;e3, &amp;e4);
</pre>

<p>&hellip;putting the elements in the order <code class=C>e2</code>,
<code class=C>e4</code>, <code class=C>e3</code>, <code
class=C>e1</code>.</p>

<p>To traverse a list:</p>

<pre class=C>
struct mydata *p;

for (p = dllist_first(&amp;list); p; p = dllist_next(others, p)) {
  /* ... */
}
</pre>

<p>Similarly, there are macros <code class=C>dllist_last</code> and
<code class=C>dllist_prev</code>.</p>

<p><code class=C>dllist_isempty(&amp;list)</code> is non-zero if the
list is empty.</p>

<p><code class=C>dllist_unlink(&amp;list, others, &amp;e2)</code>
removes element <code class=C>e2</code> from the list.</p>

<h3>Closed lists</h3>

<p>This form uses a simple header &mdash; just a pointer to any one of
the elements:</p>

<pre class=C>
typedef dllist_loophdr(struct mydata) mylooplist;
mylooplist loop = dllist_LOOPHDRINIT;

/* or */
dllist_loopinit(&amp;loop);
</pre>

<p>To add elements:</p>

<pre class=C>
/* adding elements in arbitrary order */
dllist_loopinsert(&amp;loop, others, &amp;e1);
dllist_loopinsert(&amp;loop, others, &amp;e2);

/* insert e3 after e1 */
dllist_loopinsertafter(others, &amp;e1, &amp;e3);

/* insert e4 before e1 */
dllist_loopinsertbefore(others, &amp;e1, &amp;e4);
</pre>

<p>To traverse this list:</p>

<pre class=C>
struct mydata *p, *s;

p = s = dllist_loopentry(&amp;loop);
do {
  /* ... */
  p = dllist_next(others, p);
} while (p != s);
</pre>

<p>To remove an element:</p>

<pre class=C>
dllist_loopunlink(&amp;loop, others, &e2);
</pre>

<p>If the element removed is the current head, you may want to specify
whether to move it to the next or to the previous element:</p>

<pre class=C>
dllist_loopunlinkdir(&amp;loop, others, &e2, next);
/* or */
dllist_loopunlinkdir(&amp;loop, others, &e2, prev);
</pre>

<p>To test for an empty list, use <code
class=C>dllist_loopisempty(&amp;loop)</code>.</p>

<p>To change move the head pointer by one element, use:</p>

<pre class=C>
dllist_loopinc(&amp;loop, next);
/* or */
dllist_loopinc(&amp;loop, prev);
</pre>



<h2 id="btree">Binary trees</h2>

<p>[Note: I've made the binary-heap code generic in a much better way
than I have for binary trees, so I may later implement trees the same
way.]</p>

<p>Suppose you want to maintain a binary tree of <code class=C>struct
number</code> objects, whose key fields are of type <code
class=C>int</code>.  You also want to traverse the tree in any
direction (left/right child; parent).  A header file is included to
maintain the necessary information</p>

<p>You need to declare that the structure type exists, then declare
types and functions to manipulate such structures, and then you can
complete your structure definition.  The following is suitable for a
header file:</p>

<pre class=C>
#include &lt;ddslib/btree.h&gt;

/* user's structure type */
struct element;

btree_DECL(number, struct element, int);

struct element {
  int value;
  number_elem others;
};
</pre>

<p>The first argument of <code class=C>btree_DECL</code> is a prefix:
all functions and types declared by the macro will have this prefix.
The second is the element type, and the third is the key type.</p>

<p>You also need to provide an implementation.  Make sure the above
declarations are in scope, then define a macro of the form <code
class=C>CMP(void *, int, int)</code> (i.e. the parameters are keys),
before providing it as part of the implementation:</p>

<pre class=C>
#define MYCMP(A,B,C) ((B)-(C))

btree_IMPL(number, struct element, int, others, value, MYCMP);
</pre>

<p>The first three arguments are as before.  The fourth is the name of
the member of the element type that will hold the pointers necessary
for maintaining a binary tree (we'll call this the &lsquo;link
member&rsquo;).  The fifth is the name of the member containing an
element's key.  The sixth is the comparison macro.</p>

<p>With the above declarations in scope, you can use the following
functions:</p>

<ul>

<li><pre class=C>
void number_init(struct element *ep);
</pre>

<p>Initialise the element.  This is mainly to ensure that the child
links are null.</p></li>

<li><pre class=C>
number_elem *number_find(struct element *parent,
                         struct element **rootp, int key,
                         number_elem *res,
                         void *cmpctxt);
</pre>

<p>Find the position for the given key.  <code class=C>*rootp</code>
points to the root element on entry (and may be null), and points to
the found element (or is null if not found) on exit.  <code
class=C>*parent</code> should be the element containing <code
class=C>*rootp</code> on entry, or null if the pointer does not belong
to an element (such as the pointer to the true root of the tree).
<code class=C>cmpctxt</code> is passed as the first argument to the
comparator.  <code class=C>*res</code> (or a static object if <code
class=C>res==0</code>) will hold the necessary connection information
for <code class=C>number_link()</code> (see below).  <code
class=C>res</code> (or a pointer to the static object) is
returned.</p></li>

<li><pre class=C>
void number_link(struct element *np);
</pre>

<p>Insert the element into the tree.  It is assumed that a call to
<code class=C>number_find</code> has been called, the element's key is
the same as the just sought key, and the link member has been copied
from <code class=C>*res</code>.  For example:</p>

<pre class=C>
#include &lt;stddef.h&gt;

struct element *root;
struct element newelem;

newelem.value = /* ... */;
number_find(NULL, &amp;root, newelem.value,
            number_links(&amp;newelem), NULL);
number_link(&amp;newelem);
</pre></li>

<li><pre class=C>
struct element *number_parent(struct element *);
</pre>

<p>Get the parent of the given element.</p></li>

<li><pre class=C>
struct element *number_child(struct element *np,
                             btree_dir dir);
</pre>

<p>Get the left (<code class=C>dir==btree_LEFT</code>) or right (<code
class=C>dir==btree_RIGHT</code>) child of the given element.</p></li>

<li><pre class=C>
struct element *number_next(struct element *np,
                            btree_dir dir);
</pre>

<p>Get the element before (<code class=C>dir==btree_LEFT</code>) or
after (<code class=C>dir==btree_RIGHT</code>) the given
element.</p></li>

<li><pre class=C>
struct element *number_remove(struct element *np,
                              void *cmpctxt);
</pre>

<p>Remove the element.  Other parts of the tree may be moved around to
maintain it, so a comparison context is needed.</p></li>

</ul>



<h2 id="bheap">Binary heaps</h2>

<p>A binary heap maintains a sequence of elements allowing rapid
insertion and removal at any position in the sequence.  The header
<code class=C>&lt;bheap.h&gt;</code> defines types, macros and
functions for maintaining a binary heap of identical structures in a
user-defined order.</p>

<p>The user is expected to define a type to represent a heap element,
and ensure that it contains a member of the type <code
class=C>bheap_elem</code>, for example:</p>

<pre class=C>
#include &lt;ddslib/bheap.h&gt;

struct myelem {
  int value;
  bheap_elem others;
};
</pre>

<p>The user must also define an ordering for a heap, by providing a
comparison function and a context:</p>

<pre class=C>
struct mycontext ctxt;
int mycmp(void *cp, const void *a, const void *b);
</pre>

<p><code class=C>mycmp</code> should expect <code class=C>cp</code> to
point to <code class=C>ctxt</code>, and <code class=C>a</code> and
<code class=C>b</code> to point to the two elements to be compared,
returning: a negative integer if the first should appear in the
sequence before the second; a positive integer if the first should
appear in the sequence after the second; zero if the ordering of the
two elements is unimportant.</p>

<p>Now the user can create an object of type <code
class=C>bheap</code> to represent a heap, which must be initialised
with:</p>

<pre class=C>
bheap myheap;

bheap_init(&amp;myheap, struct myelem, others, &amp;ctxt, &amp;mycmp);
</pre>

<p>The heap is maintained using the following functions or
function-like macros:</p>

<dl>

<dt><code class=C>void *bheap_peek(bheap *h);</code></dt>

<dd><p>Obtain the element at the start of the sequence <code
class=C>h</code>, or <code class=C>NULL</code> if there is
none.</p></dd>


<dt><code class=C>void bheap_insert(bheap *h, void *p);</code></dt>

<dd><p>Insert an element pointed to by <code class=C>p</code> at the
correct position within the sequence <code class=C>h</code>.</p></dd>


<dt><code class=C>void bheap_remove(bheap *h, void *p);</code></dt>

<dd><p>Remove the element pointed to by <code class=C>p</code> from
the sequence <code class=C>h</code>.</p></dd>


<dt><code class=C>void *bheap_pop(bheap *h);</code></dt>

<dd><p>Remove the first element from the sequence <code
class=C>h</code>, and return a pointer to it.</p></dd>

</dl>

<p>You need to link the library <samp>ddslib</samp> with your program
in order to use thes functions.</p>

<p>Note that no memory allocation is performed &mdash; the user
provides that himself.</p>



<h2 id="htab">Hash tables</h2>

<pre class=C>
#include &lt;ddslib/htab.h&gt;
</pre>

<p>This header defines a <code class=C>htab</code> type representing a
hash table for hashing any type to any other.  Keys and values are
represented by the unions <code class=C>htab_const</code> and <code
class=C>htab_obj</code>, which are identical except that the
<code>pointer</code> member in one of them points to a <code
class=C>const</code> object.</p>


<h3>Creating a hash table</h3>

<p>To create hash table, you need to define several functions to
manipulate data that will go in it.  Firstly, a function to compute a
hash code for any given key is required:</p>

<pre class=C>
size_t my_hash(void *context, htab_const key);
</pre>

<p>The functions <code class=C>htab_hash_str</code> and <code
class=C>htab_hash_wcs</code> are already provided to compute hash
codes from null-terminated strings (multibyte and wide,
respectively).</p>

<p>Also required is a function to compare a sought key against one
already in the table:</p>

<pre class=C>
int my_cmp(void *context, htab_const sought, htab_const extant);
</pre>

<p>The functions <code class=C>htab_cmp_str</code> and <code
class=C>htab_cmp_wcs</code> are already provided to compare
null-terminated strings (multibyte and wide, respectively).</p>

<p>The remaining functions are optional, and can be <code
class=C>NULL</code>.</p>

<p>Two functions, possibly the same one, can be specified to copy a
key or value:</p>

<pre class=C>
htab_obj my_copykey(void *context, htab_const key);
htab_obj my_copyvalue(void *context, htab_const value);
</pre>

<p>The functions <code class=C>htab_copy_str</code> and <code
class=C>htab_copy_wcs</code> are already provided to copy
null-terminated strings (multibyte and wide, respectively) by
dynamically allocating with <code class=C>malloc</code>.</p>

<p>The remaining two functions, which may also be identical, can be
specified to release a key or value object:</p>

<pre class=C>
void my_freekey(void *context, htab_obj key);
void my_freevalue(void *context, htab_obj value);
</pre>

<p>A single function <code class=C>htab_release_free</code> is
provided to release anything allocated using <code
class=C>malloc</code> by calling <code class=C>free</code>.</p>

<p>With these functions in place, you can call:</p>

<pre class=C>
htab my_table;

my_table = htab_open(size,
                     context,
                     &amp;my_hash,
                     &amp;my_cmp,
                     &amp;my_copykey,
                     &amp;my_copyvalue,
                     &amp;my_freekey,
                     &amp;my_freevalue);
</pre>

<p>A <code class=C>NULL</code> return indicates failure.</p>

<p>The <code class=C>context</code> argument is supplied on each call
to configuration functions.</p>



<h3>Destroying a hash table</h3>

<p>To discard a table after use, call:</p>

<pre class=C>
htab_close(my_table);
</pre>



<h3>Insertion</h3>

<p>To place an entry in the table, use:</p>

<pre class=C>
if (htab_put(my_table, key, value)) {
  // Insertion was successful.
}
</pre>

<p>The old value, if any, will be released using the deallocation
function specified when the table was created.  If you want to extract
it instead, use:</p>

<pre class=C>
htab_obj oldvalue;

switch (htab_rpl(my_table, key, &amp;oldvalue, value)) {
case htab_REPLACED:
  // There was a previous value.
  break;
case htab_ERROR:
  // Insertion failed.
  break;
case htab_OKAY:
  // Insertion was successful.
  break;
}
</pre>


<h3>Removal</h3>

<p>To remove an entry from the table, use:</p>

<pre class=C>
if (htab_del(my_table, key)) {
  // There was an old value.
}
</pre>

<p>The old value will be released using the deallocation function
specified when the table was created.  If you want to extract it
instead, use:</p>

<pre class=C>
htab_obj value;
if (htab_pop(my_table, key, &amp;value)) {
  // There was an old value.
}
</pre>


<h3>Inspection</h3>

<p>You can obtain the value for a specific <code class=C>key</code>
with:</p>

<pre class=C>
htab_obj value;
if (htab_get(my_table, key, &amp;value)) {
  // Value found...
}
</pre>

<p>Give <code class=C>NULL</code> as the third argument if you only
want to test for existence, or use the equivalent <code
class=C>htab_tst(my_table, key)</code>.</p>


<h3>Traversal</h3>

<p>To apply a function of the following form:</p>

<pre class=C>
htab_apprc my_func(void *app_ctxt, htab_const key, htab_obj value);
</pre>

<p>&hellip;to all entries in a table, use:</p>

<pre class=C>
htab_apply(my_table, app_ctxt, &amp;my_func);
</pre>

<p>The function should return a bit-wise OR of the following values,
as requireed:</p>

<dl>

<dt><code class=C>htab_REMOVE</code></dt>

<dd><p>Remove the entry just supplied.</p></dd>

<dt><code class=C>htab_STOP</code></dt>

<dd><p>Halt the traversal.</p></dd>

</dl>

<p>The function should not otherwise attempt to modify the table.</p>


<h3>Adaptation functions</h3>

<p>Some functions are provided to conveniently adapt the hash-table
interface to the types it actually uses.</p>

<pre class=C>
<var>CV</var> htab_get<var>S</var><var>T</var>(htab, <var>K</var> key);
<var>V</var> htab_pop<var>S</var><var>T</var>(htab, <var>K</var> key);
<var>V</var> htab_rpl<var>S</var><var>T</var>(htab, <var>K</var> key, <var>CV</var> val);
_Bool htab_put<var>S</var><var>T</var>(htab, <var>K</var> key, <var>CV</var> val);
_Bool htab_tst<var>S</var><var>T</var>(htab, <var>K</var> key);
_Bool htab_del<var>S</var><var>T</var>(htab, <var>K</var> key);
</pre>

<p>Each corresponds to one of the native functions already described,
except that the <samp>get</samp> and <samp>pop</samp> calls return the
current/removed value, or a &lsquo;miss&rsquo; value.</p>

<p>The <var>S</var> character indicates the key type <var>K</var>,
while <var>T</var> corresponds to the value types <var>V</var>.
<var>CV</var> is the unmodifiable version of <var>V</var> &mdash;
where a <var>CV</var> is returned, the table still holds that value,
and it should not be released; otherwise, the caller is expected to be
responsible for releasing it.</p>

<table>
<thead>

<tr><th><var>S</var> or <var>T</var></th> <th>Type</th> <th>Field of
<code class=C>htab_obj</code> or <code class=C>htab_const</code></th>
<th>&lsquo;Miss&rsquo; value</th></tr>

</thead>

<tbody>

<tr><td><samp>s</samp></td> <td>Null-terminated <code
class=C>char</code> string</td> <td><code class=C>pointer</code></td>
<td><code class=C>NULL</code></td></tr>

<tr><td><samp>w</samp></td> <td>Null-terminated <code
class=C>wchar_t</code></td> <td><code class=C>pointer</code></td>
<td><code class=C>NULL</code></td></tr>

<tr><td><samp>p</samp></td> <td><code class=C>void*</code></td>
<td><code class=C>pointer</code></td> <td><code
class=C>NULL</code></td></tr>

<tr><td><samp>u</samp></td> <td><code class=C>uintmax_t</code></td>
<td><code class=C>unsigned_integer</code></td> <td><code
class=C>0</code></td></tr>

</tbody>
</table>

<p>The suites for the following <var>S</var><var>T</var> combinations
are defined:</p>

<ul>
<li><samp>sp</samp></li>
<li><samp>ss</samp></li>
<li><samp>wp</samp></li>
<li><samp>ww</samp></li>
<li><samp>ws</samp></li>
<li><samp>sw</samp></li>
<li><samp>pp</samp></li>
<li><samp>su</samp></li>
</ul>

<p>More may be added in future.  You can add your own static ones with
(for example):</p>

<pre class=C>
htab_IMPL(<var>suffix</var>, <var>key-type</var>,
          <var>value-type</var>, <var>const-value-type</var>,
          static inline, <var>key-member</var>, <var>value-member</vat>,
          <var>&lsquo;miss&rsquo;-value</var>);
</pre>

<h2 id="vstr">Variable-length strings</h2>

<pre class=C>
#include &lt;ddslib/vstr.h&gt;
#include &lt;ddslib/vwcs.h&gt;
</pre>

<p>These headers respectively define the types <code
class=C>vstr</code> and <code class=C>vwcs</code> to hold strings of
multibyte or wide characters.  They are held as a base address and a
length, and include a capacity which is at least the length.
Insertions and deletions automatically adjust the capacity as
necessary.  Null-terminated, measured or <code
class=C>printf</code>-format strings can be inserted.  Strings can be
made null-terminated for compatibility easily.</p>

<p>The APIs for wide-character strings are identical to
multibyte-character strings, except for changing the prefix <code
class=C>vstr_</code> to <code class=C>vwcs_</code>, and <code
class=C>char</code> to <code class=C>wchar_t</code>.  The rest of this
documentation describes only the <code class=C>vstr_*</code>
functions.</p>

<h3>Null state</h3>

<p>A non-zero-initialised variable variable should be initialised with
<code class=C>vstr_NULL</code>.  In this state, it is safe to destroy.
To reset to this state, use:</p>

<pre class=C>
vstr str;
vstr_reset(&amp;str);
</pre>

<h3>Interoperability</h3>

<p>Use <code class=C>vstr_get</code> to obtain the address of the
first character (or a null pointer if in its null state), and <code
class=C>vstr_len</code> to obtain its length.  For example, to print
out a string containing no null characters:</p>

<pre class=C>
printf("%.*s", (int) vstr_len(&amp;str), vstr_get(&amp;str));
</pre>

<p><code class=C>vstr_term</code> will <em>ensure</em> that the string
terminates with a null character.  If it already does, the operation
does nothing.  The <code class=C>vstr_unterm</code> function performs
the inverse operation.</p>

<pre class=C>
vstr_term(&amp;str);
vstr_unterm(&amp;str); // Should always be successful.
</pre>

<p>They return zero on success or -1 on error.</p>

<h3>Insertions</h3>

<p>To make space for inserting <code class=C>len</code> characters
starting at position <code class=C>start</code>, use:</p>

<pre class=C>
vstr_splice(&amp;str, start, len);
</pre>

<p>To insert an array of characters, including nulls:</p>

<pre class=C>
vstr_insertn(&amp;str, start, "Hello", 5);
</pre>

<p>To insert a single character several times:</p>

<pre class=C>
vstr_insertn(&amp;str, start, 'H', 5);
</pre>

<p>To insert a null-terminated string, excluding the null:</p>

<pre class=C>
vstr_insert(&amp;str, start, "Hello");
</pre>

<p><code class=C>vstr_insertf</code> takes a <code
class=C>printf</code>-style format string and a variable number of
arguments:</p>

<pre class=C>
vstr_insertf(&amp;str, start, "Size %d x %d", width, height);
</pre>

<p><code class=C>vstr_vinsertf</code> is similar but takes a <code
class=C>va_list</code> instead of the variable arguments.</p>

<p>There is also a suite of functions which insert from another <code
class=C>vstr</code>.  In regular-expression format, their names are:
<code class=C>vstr_insertv[ir]?n?</code>.  For each of these, the
first two arguments are as before: <code class=C>vstr*</code> of the
string to be modified, and a <code class=C>size_t</code> giving the
insertion point.  The next argument is then a <code class=C>const
vstr*</code>, giving the source string.  An <samp>i</samp> or
<samp>r</samp> in the name indicates that a further <code
class=C>size_t</code> is required to specify the start point within
the source string (<samp>i</samp> means &lsquo;index from the
start&rsquo;; <samp>r</samp> means &lsquo;index from the end&rsquo;).
An <samp>n</samp> indicates an extra <code class=C>size_t</code>
specifying the maximum number of characters to be copied.</p>

<p>All insertion functions clamp the insertion point to within the
original array.  For each <code class=C>vstr_*insert*</code> function,
there is a corresponding <code class=C>vstr_*append*</code> function
which inserts at the end &mdash; the second argument to the insertion
function, the string index, is absent.</p>

<p>All the insertion functions and <code class=C>vstr_splice</code>
return zero on success and -1 on failure.</p>

<h4>Inserting a wide-character string into a multibyte string</h4>

<p>If you want to write a wide-character string into a <code
class=C>vstr</code>, ensure the locale is set to that <code
class=C>snprintf</code> will convert correctly.  If the wide-character
string is at <code class=C>wbase</code>, and is null-terminated, this
should be enough:</p>

<pre class=C>
vstr_insertf(&amp;str, start, "%ls", wbase);
</pre>

<p>However, if the string is not null-terminated, but you have its
length (in <code class=C>wlen</code>, below), you might expect the
following to be reliable:</p>

<pre class=C>
vstr_insertf(&amp;str, start, "%.*ls", (int) wlen, wbase);
</pre>

<p>Unfortunately, if the inserted string contains wide characters that
will be converted into multibyte characters, you will find some of the
trailing characters truncated.  This is because the precision field is
specified in terms of output bytes, not input wide characters (or
output multibyte characters).  You need to compute how many actual
bytes are generated by the wide-character string first, and a utility
<code class=C>vstr_wcsmblen</code> is provided for that:</p>

<pre class=C>
vstr_insertf(&amp;str, start, "%.*ls", vstr_wcsmblen(wbase, wlen), wbase);
</pre>

<p>The function is also suitable for <code class=C>snprintf</code> and
related functions, as <code class=C>vstr_insertf</code> simply passes
the format string and arguments straight to that.</p>

<h3>Elisions</h3>

<p>To remove several characters, use:</p>

<pre class=C>
vstr_elide(&amp;str, start, length);
</pre>

<p>To remove the tail of a string, use:</p>

<pre class=C>
vstr_truncate(&amp;str, start);
</pre>

<p>To remove all characters without adjusting the capacity, use:</p>

<pre class=C>
vstr_clear(&amp;str);
</pre>

<p>This doesn't change the string to a null pointer, although it might
be already.</p>

<p>To make an empty, but non-null string, use:</p>

<pre class=C>
if (vstr_empty(&amp;str) &lt; 0) {
  // Memory allocation failed.
}
</pre>

<h3>Optimisation</h3>

<p>The following makes the string capacity match the length exactly,
so it uses the minimum amount of memory:</p>

<pre class=C>
vstr_compact(&amp;str);
</pre>

<p><code class=C>vstr_setcap</code> tries to set the capacity to the
specified amount.  <code class=C>vstr_ensure</code> is similar, but
never reduces the capacity:</p>

<pre class=C>
vstr_setcap(&amp;str, 100);
vstr_ensure(&amp;str, 100);
</pre>

<p>They return 0 on success, and -1 on failure &mdash; either the
memory could not be allocated, or the string would have been
truncated.</p>

<h3>Extraction</h3>

<p>If you don't want your string to be managed by the library any
more, you can extract it with:</p>

<pre class=C>
char *ptr = vstr_extract(&amp;str);
</pre>

<p><code class=C>str</code> becomes <code class=C>vstr_NULL</code>,
but <code class=C>ptr</code> now points to a dynamically allocated
string suitable for use with <code class=C>free</code> or <code
class=C>realloc</code>.  <code class=C>vstr_extract</code> does not
null-terminate the string, but does compact it, before returning
it.</p>

</body>

</html>
